import scatterPlot from './scatterPlot'
import linePlot from './linePlot'
import radialPlot from './radialPlot'
import radialPlot2 from './radialPlot2'
import applyFilter from './applyFilter'
import filterData from './filterData'


     const div1 = "viz1";
     const div2 = "viz2";
     const div3 = "viz3";
     const div4 = "viz4";
     const div5 = "viz5";
     const div6 = "viz6";
     const div7 = "viz7";
     const div8 = "viz8";
     const div9 = "viz9";

      //set x and y value pointers and axis labels
      const xValue1 = d => d.temp;
      const xValue2 = d => d.hum;
      const xValue3 = d => d.windspeed;
      const xValue4 = d => d.dteday;
      const xValue5 = d => d.hr;
      const xLabel1 = 'Temperature';
      const xLabel2 = 'Humidity';
      const xLabel3 = 'Windspeed';
      const xLabel4 = 'Date';
      const yValue2 = d => d.casual;
      const yValue1 = d => d.registered;
      const yValue3 = d => d.cnt;
      const yValue4 = xValue1;
      const yLabel1 = 'Users';
      const yLabel2 = 'Users';
      const yLabel3 = 'Users';
      const yLabel4 = xLabel1;
      const pointSize = 5;
      const pointColor1 = "green";
      const pointColor2 = "blue";
      const pointColor3 = "grey";
      const filterValue = d => d.filterOpacity;


      const minDate = new Date(2011,0,1);
      const maxDate = new Date(2012,11,31);

      // initialize filter variables
      var startDate = new Date(2011,0,1);
      var endDate = new Date(2012,11,31);
      var year2011Filter=true;
      var year2012Filter=true;
      var dayTypeWorkingFilter=true;
      var dayTypeNonWorkingFilter=true;
      var weatherSit1Filter=true;
      var weatherSit2Filter=true;
      var weatherSit3Filter=true;


      const margin = { left: 60, right: 10, top: 10, bottom: 60 };

      //initialize these variables in the Global Scope
      //so they can be accessed by any function

      //row function to parse daily csv
      const row1 = d => {
          d.instant = +d.instant;
          d.dteday = new Date(d.dteday); //need to parse date
          d.season = +d.season;
          d.yr = +d.yr;
          d.mnth = +d.mnth;
          d.holiday = +d.holiday; //flag
          d.weekday = +d.weekday; //integer day of week (0-6)
          d.workingday = +d.workingday; //flag
          d.weathersit = +d.weathersit; //(1-4)
          d.temp = +d.temp;
          d.atemp = +d.atemp;
          d.hum = +d.hum;
          d.windspeed = +d.windspeed;
          d.casual = +d.casual;
          d.registered = +d.registered;
          d.cnt = +d.cnt;
          d.filterOpacity=1;
          return d;
      };

      const row2 = d => {
          d.instant = +d.instant;
          d.dteday = new Date(d.dteday); //need to parse date
          d.hr = +d.hr;
          d.season = +d.season;
          d.yr = +d.yr;
          d.mnth = +d.mnth;
          d.holiday = +d.holiday; //flag
          d.weekday = +d.weekday; //integer day of week (0-6)
          d.workingday = +d.workingday; //flag
          d.weathersit = +d.weathersit; //(1-4)
          d.temp = +d.temp;
          d.atemp = +d.atemp;
          d.hum = +d.hum;
          d.windspeed = +d.windspeed;
          d.casual = +d.casual;
          d.registered = +d.registered;
          d.cnt = +d.cnt;
          d.filterOpacity=.25;
          return d;
      };

var dataHour =[],dataDay = [];  //initialize dataHour outside of function

d3.csv('data/hour.csv', row1, data => {

  dataHour = data
  //use nest to groupby day and rollup based on
  //parameter specific rollup parameters
  //(i.e., mean, max or sum)
  var nestbyday = d3.nest()
    			.key(d => d.dteday)
        	.rollup(function(d) {
            return{
              'dteday': new Date(d3.mean(d, e=>+e.dteday)),
              'season': d3.mean(d, e=>+e.season),
              'yr': d3.mean(d, e=>+e.yr),
              'mnth': d3.mean(d, e=>+e.mnth),
              'holiday': d3.mean(d, e=>+e.holiday),
              'weekday': d3.mean(d, e=>+e.weekday),
              'workingday': d3.mean(d, e=>+e.workingday),
              'weathersit': d3.max(d, e=>+e.weathersit),
              'temp': d3.mean(d, e=>+e.temp),
              'atemp': d3.mean(d, e=>+e.atemp),
              'hum': d3.mean(d, e=>+e.hum),
              'windspeed':d3.mean(d, e=>+e.windspeed),
              'casual': d3.sum(d, e=>+e.casual),
              'registered': d3.sum(d, e=>+e.registered),
              'cnt':  d3.sum(d, e=>+e.cnt)
            };
          })
         	.entries(data);
      //console.log(nestbyday);

      //unnest creates an array of objects from the
      //array of key:valueObject pairs generated by
      //d3.nest

      //unnest adapted from 		      //https://bl.ocks.org/SpaceActuary/723b26e187e6bbc2608f

      function unnest(data, children){
          var output=[];
          data.forEach((d,i)=>{
            output.push(d[children]);
            })
				return output;
        };

      dataDay = unnest(nestbyday, "value");
      //console.log(dataDay);

      // startDate = d3.min(dataDay, d=>d.dteDay);
      // endDate = d3.max(dataDay, d=>d.dteDay);
      console.log(dataHour)
      console.log(dataDay)

//render function for all visualizations
  function render(){
    console.log("update filter and echo to console")

    var dateRange = d3.extent(dataDay, d=>d.dteday);
    console.log('date range: '+ dateRange[0] +" to "+dateRange[1]);

    //set defaultOpacity
    let unfilteredOpacity = .25;
    applyFilter(dataHour,{
      dateRange,
      year2011Filter,
      year2012Filter,
      dayTypeWorkingFilter,
      dayTypeNonWorkingFilter,
      weatherSit1Filter,
      weatherSit2Filter,
      weatherSit3Filter,
      unfilteredOpacity
    });

    applyFilter(dataDay,{
      dateRange,
      year2011Filter,
      year2012Filter,
      dayTypeWorkingFilter,
      dayTypeNonWorkingFilter,
      weatherSit1Filter,
      weatherSit2Filter,
      weatherSit3Filter,
      unfilteredOpacity
    });

    const dataHourFiltered = filterData(dataHour,{
      dateRange,
      year2011Filter,
      year2012Filter,
      dayTypeWorkingFilter,
      dayTypeNonWorkingFilter,
      weatherSit1Filter,
      weatherSit2Filter,
      weatherSit3Filter,
      unfilteredOpacity
    });

    const dataDayFiltered =filterData(dataDay,{
      dateRange,
      year2011Filter,
      year2012Filter,
      dayTypeWorkingFilter,
      dayTypeNonWorkingFilter,
      weatherSit1Filter,
      weatherSit2Filter,
      weatherSit3Filter,
      unfilteredOpacity
    });


    //first row of grids

    //note that div1 labels do not correspond to
    //final sequence of charts
    scatterPlot(div1, {
      data:dataDay, //Filtered,
      xValue:xValue1,
      yValue:yValue1,
      xLabel:xLabel1,
      yLabel:yLabel1,
      colorValue:pointColor1,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div1")

    scatterPlot(div2, {
      data:dataDay, //Filtered,
      xValue:xValue2,
      yValue:yValue1,
      xLabel:xLabel2,
      yLabel:yLabel1,
      colorValue:pointColor1,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div2")

    scatterPlot(div3, {
      data:dataDay, //Filtered,
      xValue:xValue3,
      yValue:yValue1,
      xLabel:xLabel3,
      yLabel:yLabel1,
      colorValue:pointColor1,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div3")

    radialPlot2(div4, {
      data:dataHourFiltered,
      hour:xValue5,
      yValue:yValue1,
      yLabel:yLabel1,
      colorValue:pointColor1,
      margin:margin
    });

    console.log("div4")

    //second row of grid
    scatterPlot(div5, {
      data:dataDay, //Filtered,
      xValue:xValue1,
      yValue:yValue2,
      xLabel:xLabel1,
      yLabel:yLabel2,
      colorValue:pointColor2,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div5")

    scatterPlot(div6, {
      data:dataDay, //Filtered,
      xValue:xValue2,
      yValue:yValue2,
      xLabel:xLabel2,
      yLabel:yLabel2,
      colorValue:pointColor2,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div6")

    scatterPlot(div7, {
      data:dataDay, //Filtered,
      xValue:xValue3,
      yValue:yValue2,
      xLabel:xLabel3,
      yLabel:yLabel2,
      colorValue:pointColor2,
      pointSize:pointSize,
      margin:margin,
      filterValue:filterValue
    });

    console.log("div7")

    radialPlot(div8, {
      data:dataHourFiltered,
      hour:xValue5,
      yValue:yValue2,
      yLabel:yLabel2,
      colorValue:pointColor2,
      margin:margin
    });

    console.log("div8")

    linePlot(div9, {
      data:dataDay,
      xValue:xValue4,
      yValue1:yValue1,
      yValue2:yValue2,
      xLabel:xLabel4,
      yLabel:"Users",
      colorValue:pointColor2,
      pointSize√ü:pointSize,
      margin:margin
    });


  };




  render();

  //evenet listeners
  window.addEventListener('resize',render);



//event handler for bootstrap toggle switch UI elements
$(function() {

  	$('#year2011').change(function() {
      year2011Filter = $(this).prop('checked');
      console.log(year2011Filter);
      render()
    });

    $('#year2012').change(function() {
      year2012Filter = $(this).prop('checked');
      console.log(year2012Filter);
      render()
		});

    $('#dayTypeWorking').change(function() {
      dayTypeWorkingFilter = $(this).prop('checked');
      console.log(dayTypeWorkingFilter);
      render()
    });


    $('#dayTypeNonWorking').change(function() {
      dayTypeNonWorkingFilter = $(this).prop('checked');
      console.log(dayTypeNonWorkingFilter);
      render()
    });

    $('#weatherSit1').change(function() {
      weatherSit1Filter = $(this).prop('checked');
      console.log(weatherSit1Filter);
      render()
    });

     $('#weatherSit2').change(function() {
      weatherSit2Filter = $(this).prop('checked') ;
      console.log(weatherSit2Filter);
      render()
    });

      $('#weatherSit3').change(function() {
      weatherSit3Filter = $(this).prop('checked');
      console.log(weatherSit1Filter);
      render()
    });
});
});
